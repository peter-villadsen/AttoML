(* Polymorphic Option Module *)

(* The polymorphic option type - works for ALL types! *)
datatype 'a option = None | Some of 'a

structure Option = {
    fun isSome opt = match opt with Some _ -> true
      | None -> false end,

    fun isNone opt = match opt with Some _ -> false
      | None -> true end,

    fun getOr opt default = match opt with Some x -> x
      | None -> default end,

    fun map f opt = match opt with Some x -> Some (f x)
      | None -> None end,

    fun bind f opt = match opt with Some x -> f x
      | None -> None end,

    fun filter pred opt = match opt with Some x -> if pred x then Some x else None
      | None -> None end,

    fun fold onSome onNone opt = match opt with Some x -> onSome x
      | None -> onNone () end,

    fun toList opt = match opt with Some x -> [x]
      | None -> [] end,

    fun fromList lst = match lst with h::_ -> Some h
      | [] -> None end,

    fun orElse opt1 opt2 = match opt1 with Some _ -> opt1
      | None -> opt2 end,

    fun andThen f opt = bind f opt,

    fun map2 f opt1 opt2 = match opt1 with Some x -> (match opt2 with Some y -> Some (f x y)
          | None -> None end)
      | None -> None end
}

(* Example usage with pipe operator (|>):

   (* Chain option operations *)
   Some 10
   |> Option.map (fun x -> x * 2)
   |> Option.filter (fun x -> x > 15)
   |> Option.map (fun x -> x + 100)
   (* Result: Some 120 *)

   (* Convert and process *)
   [42]
   |> Option.fromList
   |> Option.map (fun x -> x + 1)
   |> Option.getOr 0
   (* Result: 43 *)
*)
