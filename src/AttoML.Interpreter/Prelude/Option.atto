(* Polymorphic Option Module *)

(* The polymorphic option type - works for ALL types! *)
datatype 'a option = None | Some of 'a

structure Option = {
    fun isSome opt = case opt of
        Some _ -> true
      | None -> false,

    fun isNone opt = case opt of
        Some _ -> false
      | None -> true,

    fun getOr opt default = case opt of
        Some x -> x
      | None -> default,

    fun map f opt = case opt of
        Some x -> Some (f x)
      | None -> None,

    fun bind f opt = case opt of
        Some x -> f x
      | None -> None,

    fun filter pred opt = case opt of
        Some x -> if pred x then Some x else None
      | None -> None,

    fun fold onSome onNone opt = case opt of
        Some x -> onSome x
      | None -> onNone (),

    fun toList opt = case opt of
        Some x -> [x]
      | None -> [],

    fun fromList lst = case lst of
        h::_ -> Some h
      | [] -> None,

    fun orElse opt1 opt2 = case opt1 of
        Some _ -> opt1
      | None -> opt2,

    fun andThen f opt = bind f opt,

    fun map2 f opt1 opt2 = case opt1 of
        Some x -> (case opt2 of
            Some y -> Some (f x y)
          | None -> None)
      | None -> None
}

(* Example usage with pipe operator (|>):

   (* Chain option operations *)
   Some 10
   |> Option.map (fun x -> x * 2)
   |> Option.filter (fun x -> x > 15)
   |> Option.map (fun x -> x + 100)
   (* Result: Some 120 *)

   (* Convert and process *)
   [42]
   |> Option.fromList
   |> Option.map (fun x -> x + 1)
   |> Option.getOr 0
   (* Result: 43 *)
*)
