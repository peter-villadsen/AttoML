(* LaTeXRewrite Module - Rewrite rules and cost model for LaTeX optimization *)

structure LaTeXRewrite = {
  (* Cost model optimized for LaTeX formatting *)
  fun latexCost node =
    case node of
      ENode.EConst _ -> 1.0
    | ENode.EVar _ -> 1.0
    | ENode.EDiv _ -> 2.0    (* Prefer \frac over mul/pow *)
    | ENode.EAdd _ -> 3.0
    | ENode.ESub _ -> 3.0
    | ENode.EMul _ -> 4.0    (* Penalize to encourage factoring *)
    | ENode.EPow _ -> 3.0
    | ENode.ESin _ -> 2.0
    | ENode.ECos _ -> 2.0
    | ENode.ELog _ -> 2.0
    | ENode.ENeg _ -> 5.0,   (* Penalize negation, prefer subtraction *)

  (* Helper to create rewrite rules as tuples: (name, pattern, template) *)
  fun mkRule (name, pat, tmpl) = (name, pat, tmpl),

  (* EPattern variables *)
  fun pvar s = EPattern.PVar s,
  fun tvar s = Template.TVar s,

  (* Algebraic rewrite rules *)
  fun algebraicRules dummy = [
    (* Commutativity *)
    mkRule ("add_comm",
      EPattern.PAdd (pvar "?a", pvar "?b"),
      Template.TAdd (tvar "?b", tvar "?a")),

    mkRule ("mul_comm",
      EPattern.PMul (pvar "?a", pvar "?b"),
      Template.TMul (tvar "?b", tvar "?a")),

    (* Associativity - right to left *)
    mkRule ("add_assoc_rl",
      EPattern.PAdd (EPattern.PAdd (pvar "?a", pvar "?b"), pvar "?c"),
      Template.TAdd (tvar "?a", Template.TAdd (tvar "?b", tvar "?c"))),

    mkRule ("mul_assoc_rl",
      EPattern.PMul (EPattern.PMul (pvar "?a", pvar "?b"), pvar "?c"),
      Template.TMul (tvar "?a", Template.TMul (tvar "?b", tvar "?c"))),

    (* Associativity - left to right *)
    mkRule ("add_assoc_lr",
      EPattern.PAdd (pvar "?a", EPattern.PAdd (pvar "?b", pvar "?c")),
      Template.TAdd (Template.TAdd (tvar "?a", tvar "?b"), tvar "?c")),

    mkRule ("mul_assoc_lr",
      EPattern.PMul (pvar "?a", EPattern.PMul (pvar "?b", pvar "?c")),
      Template.TMul (Template.TMul (tvar "?a", tvar "?b"), tvar "?c")),

    (* Identity *)
    mkRule ("add_zero_l",
      EPattern.PAdd (EPattern.PConst 0.0, pvar "?a"),
      tvar "?a"),

    mkRule ("add_zero_r",
      EPattern.PAdd (pvar "?a", EPattern.PConst 0.0),
      tvar "?a"),

    mkRule ("mul_one_l",
      EPattern.PMul (EPattern.PConst 1.0, pvar "?a"),
      tvar "?a"),

    mkRule ("mul_one_r",
      EPattern.PMul (pvar "?a", EPattern.PConst 1.0),
      tvar "?a"),

    mkRule ("pow_one",
      EPattern.PPow (pvar "?a", EPattern.PConst 1.0),
      tvar "?a"),

    (* Distribution *)
    mkRule ("distrib_lr",
      EPattern.PMul (pvar "?a", EPattern.PAdd (pvar "?b", pvar "?c")),
      Template.TAdd (Template.TMul (tvar "?a", tvar "?b"), Template.TMul (tvar "?a", tvar "?c"))),

    mkRule ("distrib_rl",
      EPattern.PMul (EPattern.PAdd (pvar "?a", pvar "?b"), pvar "?c"),
      Template.TAdd (Template.TMul (tvar "?a", tvar "?c"), Template.TMul (tvar "?b", tvar "?c"))),

    (* Factoring (reverse of distribution) *)
    mkRule ("factor",
      EPattern.PAdd (EPattern.PMul (pvar "?a", pvar "?b"), EPattern.PMul (pvar "?a", pvar "?c")),
      Template.TMul (tvar "?a", Template.TAdd (tvar "?b", tvar "?c"))),

    (* Fraction conversion: a * b^-1 -> a / b *)
    mkRule ("frac_conv",
      EPattern.PMul (pvar "?a", EPattern.PPow (pvar "?b", EPattern.PConst (0.0 - 1.0))),
      Template.TDiv (tvar "?a", tvar "?b")),

    (* Fraction combination: a/c + b/c -> (a+b)/c *)
    mkRule ("frac_add",
      EPattern.PAdd (EPattern.PDiv (pvar "?a", pvar "?c"), EPattern.PDiv (pvar "?b", pvar "?c")),
      Template.TDiv (Template.TAdd (tvar "?a", tvar "?b"), tvar "?c")),

    (* Double negation: --a -> a *)
    mkRule ("double_neg",
      EPattern.PNeg (EPattern.PNeg (pvar "?a")),
      tvar "?a"),

    (* Negative addition: a + -b -> a - b *)
    mkRule ("neg_to_sub",
      EPattern.PAdd (pvar "?a", EPattern.PNeg (pvar "?b")),
      Template.TSub (tvar "?a", tvar "?b")),

    (* Power laws: a^n * a^m -> a^(n+m) *)
    mkRule ("pow_mul",
      EPattern.PMul (EPattern.PPow (pvar "?a", pvar "?n"), EPattern.PPow (pvar "?a", pvar "?m")),
      Template.TPow (tvar "?a", Template.TAdd (tvar "?n", tvar "?m"))),

    (* Power distributes over multiplication: (a*b)^n <-> a^n * b^n *)
    mkRule ("pow_distrib_mul",
      EPattern.PPow (EPattern.PMul (pvar "?a", pvar "?b"), pvar "?n"),
      Template.TMul (Template.TPow (tvar "?a", tvar "?n"), Template.TPow (tvar "?b", tvar "?n"))),

    mkRule ("pow_distrib_mul_rev",
      EPattern.PMul (EPattern.PPow (pvar "?a", pvar "?n"), EPattern.PPow (pvar "?b", pvar "?n")),
      Template.TPow (Template.TMul (tvar "?a", tvar "?b"), tvar "?n")),

    (* Power distributes over division: (a/b)^n <-> a^n / b^n *)
    mkRule ("pow_distrib_div",
      EPattern.PPow (EPattern.PDiv (pvar "?a", pvar "?b"), pvar "?n"),
      Template.TDiv (Template.TPow (tvar "?a", tvar "?n"), Template.TPow (tvar "?b", tvar "?n"))),

    mkRule ("pow_distrib_div_rev",
      EPattern.PDiv (EPattern.PPow (pvar "?a", pvar "?n"), EPattern.PPow (pvar "?b", pvar "?n")),
      Template.TPow (Template.TDiv (tvar "?a", tvar "?b"), tvar "?n")),

    (* Power of power: (a^m)^n <-> a^(m*n) *)
    mkRule ("pow_pow",
      EPattern.PPow (EPattern.PPow (pvar "?a", pvar "?m"), pvar "?n"),
      Template.TPow (tvar "?a", Template.TMul (tvar "?m", tvar "?n"))),

    mkRule ("pow_pow_rev",
      EPattern.PPow (pvar "?a", EPattern.PMul (pvar "?m", pvar "?n")),
      Template.TPow (Template.TPow (tvar "?a", tvar "?m"), tvar "?n")),

    (* Negative exponent: a^(-n) <-> 1/(a^n) *)
    mkRule ("neg_exp",
      EPattern.PPow (pvar "?a", EPattern.PNeg (pvar "?n")),
      Template.TDiv (Template.TConst 1.0, Template.TPow (tvar "?a", tvar "?n"))),

    mkRule ("neg_exp_rev",
      EPattern.PDiv (EPattern.PConst 1.0, EPattern.PPow (pvar "?a", pvar "?n")),
      Template.TPow (tvar "?a", Template.TNeg (tvar "?n"))),

    (* Trig identity: sin^2(x) + cos^2(x) -> 1 *)
    mkRule ("trig_pythagorean",
      EPattern.PAdd (
        EPattern.PPow (EPattern.PSin (pvar "?x"), EPattern.PConst 2.0),
        EPattern.PPow (EPattern.PCos (pvar "?x"), EPattern.PConst 2.0)
      ),
      Template.TConst 1.0)
  ],

  (* Logarithm rules - optional, useful for calculus/differentiation *)
  fun logarithmRules dummy = [
    (* Product rule: log(a*b) <-> log(a) + log(b) *)
    mkRule ("log_product",
      EPattern.PLog (EPattern.PMul (pvar "?a", pvar "?b")),
      Template.TAdd (Template.TLog (tvar "?a"), Template.TLog (tvar "?b"))),

    mkRule ("log_product_rev",
      EPattern.PAdd (EPattern.PLog (pvar "?a"), EPattern.PLog (pvar "?b")),
      Template.TLog (Template.TMul (tvar "?a", tvar "?b"))),

    (* Quotient rule: log(a/b) <-> log(a) - log(b) *)
    mkRule ("log_quotient",
      EPattern.PLog (EPattern.PDiv (pvar "?a", pvar "?b")),
      Template.TSub (Template.TLog (tvar "?a"), Template.TLog (tvar "?b"))),

    mkRule ("log_quotient_rev",
      EPattern.PSub (EPattern.PLog (pvar "?a"), EPattern.PLog (pvar "?b")),
      Template.TLog (Template.TDiv (tvar "?a", tvar "?b"))),

    (* Power rule: log(a^n) <-> n * log(a) *)
    mkRule ("log_power",
      EPattern.PLog (EPattern.PPow (pvar "?a", pvar "?n")),
      Template.TMul (tvar "?n", Template.TLog (tvar "?a"))),

    mkRule ("log_power_rev",
      EPattern.PMul (pvar "?n", EPattern.PLog (pvar "?a")),
      Template.TLog (Template.TPow (tvar "?a", tvar "?n")))
  ],

  (* Optimize expression for LaTeX with standard algebraic rules *)
  fun optimizeForLatex (expr, maxIters) =
    let eg0 = EGraph.empty 0 in
    let (rootId, eg1) = EGraph.add (eg0, expr) in
    let rules = algebraicRules 0 in
    let eg2 = EGraph.saturate (eg1, rules, maxIters) in
    EGraph.extract (eg2, latexCost, rootId),

  (* Optimize with logarithm rules included (for calculus contexts) *)
  fun optimizeForCalculus (expr, maxIters) =
    let eg0 = EGraph.empty 0 in
    let (rootId, eg1) = EGraph.add (eg0, expr) in
    let algRules = algebraicRules 0 in
    let logRules = logarithmRules 0 in
    let rules = algRules @ logRules in
    let eg2 = EGraph.saturate (eg1, rules, maxIters) in
    EGraph.extract (eg2, latexCost, rootId)
}
