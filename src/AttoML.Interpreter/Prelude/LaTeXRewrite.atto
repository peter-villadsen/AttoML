(* LaTeXRewrite Module - Rewrite rules and cost model for LaTeX optimization *)

structure LaTeXRewrite = {
  (* Cost model optimized for LaTeX formatting *)
  fun latexCost node =
    case node of
      ENode.EConst _ -> 1.0
    | ENode.EVar _ -> 1.0
    | ENode.EDiv _ -> 2.0    (* Prefer \frac over mul/pow *)
    | ENode.EAdd _ -> 3.0
    | ENode.ESub _ -> 3.0
    | ENode.EMul _ -> 4.0    (* Penalize to encourage factoring *)
    | ENode.EPow _ -> 3.0
    | ENode.ESin _ -> 2.0
    | ENode.ECos _ -> 2.0
    | ENode.ELog _ -> 2.0
    | ENode.ENeg _ -> 5.0,   (* Penalize negation, prefer subtraction *)

  (* Helper to create rewrite rules as tuples: (name, pattern, template) *)
  fun mkRule (name, pat, tmpl) = (name, pat, tmpl),

  (* EPattern variables *)
  fun pvar s = EPattern.PVar s,
  fun tvar s = Template.TVar s,

  (* Algebraic rewrite rules *)
  fun algebraicRules dummy = [
    (* Commutativity *)
    mkRule ("add_comm",
      EPattern.PAdd (pvar "?a", pvar "?b"),
      Template.TAdd (tvar "?b", tvar "?a")),

    mkRule ("mul_comm",
      EPattern.PMul (pvar "?a", pvar "?b"),
      Template.TMul (tvar "?b", tvar "?a")),

    (* Associativity - right to left *)
    mkRule ("add_assoc_rl",
      EPattern.PAdd (EPattern.PAdd (pvar "?a", pvar "?b"), pvar "?c"),
      Template.TAdd (tvar "?a", Template.TAdd (tvar "?b", tvar "?c"))),

    mkRule ("mul_assoc_rl",
      EPattern.PMul (EPattern.PMul (pvar "?a", pvar "?b"), pvar "?c"),
      Template.TMul (tvar "?a", Template.TMul (tvar "?b", tvar "?c"))),

    (* Associativity - left to right *)
    mkRule ("add_assoc_lr",
      EPattern.PAdd (pvar "?a", EPattern.PAdd (pvar "?b", pvar "?c")),
      Template.TAdd (Template.TAdd (tvar "?a", tvar "?b"), tvar "?c")),

    mkRule ("mul_assoc_lr",
      EPattern.PMul (pvar "?a", EPattern.PMul (pvar "?b", pvar "?c")),
      Template.TMul (Template.TMul (tvar "?a", tvar "?b"), tvar "?c")),

    (* Identity *)
    mkRule ("add_zero_l",
      EPattern.PAdd (EPattern.PConst 0.0, pvar "?a"),
      tvar "?a"),

    mkRule ("add_zero_r",
      EPattern.PAdd (pvar "?a", EPattern.PConst 0.0),
      tvar "?a"),

    mkRule ("mul_one_l",
      EPattern.PMul (EPattern.PConst 1.0, pvar "?a"),
      tvar "?a"),

    mkRule ("mul_one_r",
      EPattern.PMul (pvar "?a", EPattern.PConst 1.0),
      tvar "?a"),

    mkRule ("pow_one",
      EPattern.PPow (pvar "?a", EPattern.PConst 1.0),
      tvar "?a"),

    (* Distribution *)
    mkRule ("distrib_lr",
      EPattern.PMul (pvar "?a", EPattern.PAdd (pvar "?b", pvar "?c")),
      Template.TAdd (Template.TMul (tvar "?a", tvar "?b"), Template.TMul (tvar "?a", tvar "?c"))),

    mkRule ("distrib_rl",
      EPattern.PMul (EPattern.PAdd (pvar "?a", pvar "?b"), pvar "?c"),
      Template.TAdd (Template.TMul (tvar "?a", tvar "?c"), Template.TMul (tvar "?b", tvar "?c"))),

    (* Factoring (reverse of distribution) *)
    mkRule ("factor",
      EPattern.PAdd (EPattern.PMul (pvar "?a", pvar "?b"), EPattern.PMul (pvar "?a", pvar "?c")),
      Template.TMul (tvar "?a", Template.TAdd (tvar "?b", tvar "?c"))),

    (* Fraction conversion: a * b^-1 -> a / b *)
    mkRule ("frac_conv",
      EPattern.PMul (pvar "?a", EPattern.PPow (pvar "?b", EPattern.PConst (0.0 - 1.0))),
      Template.TDiv (tvar "?a", tvar "?b")),

    (* Fraction combination: a/c + b/c -> (a+b)/c *)
    mkRule ("frac_add",
      EPattern.PAdd (EPattern.PDiv (pvar "?a", pvar "?c"), EPattern.PDiv (pvar "?b", pvar "?c")),
      Template.TDiv (Template.TAdd (tvar "?a", tvar "?b"), tvar "?c")),

    (* Double negation: --a -> a *)
    mkRule ("double_neg",
      EPattern.PNeg (EPattern.PNeg (pvar "?a")),
      tvar "?a"),

    (* Negative addition: a + -b -> a - b *)
    mkRule ("neg_to_sub",
      EPattern.PAdd (pvar "?a", EPattern.PNeg (pvar "?b")),
      Template.TSub (tvar "?a", tvar "?b")),

    (* Power laws: a^n * a^m -> a^(n+m) *)
    mkRule ("pow_mul",
      EPattern.PMul (EPattern.PPow (pvar "?a", pvar "?n"), EPattern.PPow (pvar "?a", pvar "?m")),
      Template.TPow (tvar "?a", Template.TAdd (tvar "?n", tvar "?m"))),

    (* Trig identity: sin^2(x) + cos^2(x) -> 1 *)
    mkRule ("trig_pythagorean",
      EPattern.PAdd (
        EPattern.PPow (EPattern.PSin (pvar "?x"), EPattern.PConst 2.0),
        EPattern.PPow (EPattern.PCos (pvar "?x"), EPattern.PConst 2.0)
      ),
      Template.TConst 1.0)
  ],

  (* Optimize expression for LaTeX *)
  fun optimizeForLatex (expr, maxIters) =
    let eg0 = EGraph.empty 0 in
    let (rootId, eg1) = EGraph.add (eg0, expr) in
    let rules = algebraicRules 0 in
    let eg2 = EGraph.saturate (eg1, rules, maxIters) in
    EGraph.extract (eg2, latexCost, rootId)
}
