(* LaTeX Module - Convert symbolic expressions to LaTeX format *)

structure LaTeX = {
  (* Precedence levels:
     0 = top level (no parens)
     1 = addition/subtraction
     2 = right side of subtraction
     3 = multiplication/division
     4 = exponentiation
  *)

  (* Helper: check if expression is a simple atom *)
  fun isAtom e =
    match e with Expr.Const _ -> true
    | Expr.Var _ -> true
    | _ -> false,

  (* Helper: check if expression is numeric constant *)
  fun isNumeric e =
    match e with Expr.Const _ -> true
    | _ -> false,

  (* Helper: check if expression needs multiplication symbol *)
  fun needsMulSymbol (a, b) =
    match (a, b) with (Expr.Const _, Expr.Const _) -> true
    | (Expr.Const _, Expr.Var _) -> false      (* 2x *)
    | (Expr.Const _, _) -> true                (* 2(x+1) *)
    | (_, Expr.Const _) -> true                (* x·2 *)
    | (Expr.Var _, Expr.Var _) -> true         (* x·y *)
    | _ -> true
    end,

  (* Format float for LaTeX *)
  fun formatFloat r =
    let s = String.ofFloat r in
    if String.contains "." s then s
    else String.concat s ".0",

  (* Wrap in parentheses *)
  fun paren s = String.concat (String.concat "(" s) ")",

  (* Canonicalize: move constants to the left for readability *)
  fun canonicalize e =
    match e with Expr.Const r -> Expr.Const r
    | Expr.Var v -> Expr.Var v
    | Expr.Add (a, b) ->
        let a1 = canonicalize a in
        let b1 = canonicalize b in
        (* If b is constant but a is not, swap *)
        if isNumeric b1 then
          if isNumeric a1 then Expr.Add (a1, b1)
          else Expr.Add (b1, a1)
        else Expr.Add (a1, b1)
    | Expr.Mul (a, b) ->
        let a1 = canonicalize a in
        let b1 = canonicalize b in
        (* If b is constant but a is not, swap *)
        if isNumeric b1 then
          if isNumeric a1 then Expr.Mul (a1, b1)
          else Expr.Mul (b1, a1)
        else Expr.Mul (a1, b1)
    | Expr.Sub (a, b) ->
        let a1 = canonicalize a in
        let b1 = canonicalize b in
        Expr.Sub (a1, b1)
    | Expr.Div (a, b) ->
        let a1 = canonicalize a in
        let b1 = canonicalize b in
        Expr.Div (a1, b1)
    | Expr.Pow (a, b) ->
        let a1 = canonicalize a in
        let b1 = canonicalize b in
        Expr.Pow (a1, b1)
    | Expr.Sin a ->
        let a1 = canonicalize a in
        Expr.Sin a1
    | Expr.Cos a ->
        let a1 = canonicalize a in
        Expr.Cos a1
    | Expr.Log a ->
        let a1 = canonicalize a in
        Expr.Log a1,

  (* Convert to LaTeX with precedence *)
  fun toLatexP (e, prec) =
    match e with Expr.Const r ->
        if r < 0.0 then
          let absStr = formatFloat (0.0 - r) in
          if prec > 1 then paren (String.concat "-" absStr)
          else String.concat "-" absStr
        else formatFloat r
    | Expr.Var v -> v
    | Expr.Add (a, b) ->
        let s = String.concat (String.concat (toLatexP (a, 1)) " + ") (toLatexP (b, 1)) in
        if prec > 1 then paren s else s
    | Expr.Sub (a, b) ->
        let s = String.concat (String.concat (toLatexP (a, 1)) " - ") (toLatexP (b, 2)) in
        if prec > 1 then paren s else s
    | Expr.Mul (a, b) ->
        let aStr = toLatexP (a, 3) in
        let bStr = toLatexP (b, 3) in
        let sep = if needsMulSymbol (a, b) then " \\cdot " else "" in
        let s = String.concat (String.concat aStr sep) bStr in
        if prec > 3 then paren s else s
    | Expr.Div (a, b) ->
        let aStr = toLatexP (a, 0) in
        let bStr = toLatexP (b, 0) in
        String.concat (String.concat (String.concat "\\frac{" aStr) "}{") (String.concat bStr "}")
    | Expr.Pow (a, b) ->
        let aStr = if isAtom a then toLatexP (a, 4) else paren (toLatexP (a, 0)) in
        let bStr = toLatexP (b, 0) in
        let s = String.concat (String.concat aStr "^{") (String.concat bStr "}") in
        if prec > 4 then paren s else s
    | Expr.Sin a ->
        let aStr = toLatexP (a, 0) in
        String.concat (String.concat "\\sin(" aStr) ")"
    | Expr.Cos a ->
        let aStr = toLatexP (a, 0) in
        String.concat (String.concat "\\cos(" aStr) ")"
    | Expr.Log a ->
        let aStr = toLatexP (a, 0) in
        String.concat (String.concat "\\log(" aStr) ")",

  (* Convert to LaTeX string *)
  fun toLatex e =
    let canonical = canonicalize e in
    toLatexP (canonical, 0),

  (* Format expression with optimization *)
  fun formatOptimized (exprStr, maxIters) =
    let expr = SymCalc.parse exprStr in
    let simplified = SymCalc.simplify expr in
    let optimized = LaTeXRewrite.optimizeForLatex (simplified, maxIters) in
    toLatex optimized,

  (* Show before/after comparison *)
  fun showOptimization exprStr =
    let expr = SymCalc.parse exprStr in
    let simplified = SymCalc.simplify expr in
    let optimized = LaTeXRewrite.optimizeForLatex (simplified, 10) in
    let original = toLatex simplified in
    let result = toLatex optimized in
    String.concat (String.concat (String.concat (String.concat "Original: " original) "\nOptimized: ") result) "\n",

  (* Pipeline-friendly functions *)

  (* Simplify then convert to LaTeX *)
  fun simplifyToLatex expr = toLatex (SymCalc.simplify expr),

  (* Parse and convert to LaTeX *)
  fun parseToLatex s = toLatex (SymCalc.parse s),

  (* Parse, simplify, and convert to LaTeX *)
  fun parseSimplifyToLatex s = toLatex (SymCalc.simplify (SymCalc.parse s)),

  (* Parse, differentiate, simplify, and convert to LaTeX *)
  val parseDiffToLatex = fun v -> fun s ->
    toLatex (SymCalc.simplify (SymCalc.diff (v, SymCalc.parse s))),

  (* Differentiate (pipeline-friendly) and convert to LaTeX *)
  val diffToLatex = fun v -> fun expr ->
    toLatex (SymCalc.simplify (SymCalc.diff (v, expr))),

  (* Canonicalize and convert to LaTeX (pipeline-friendly) *)
  fun canonToLatex expr = toLatex (canonicalize expr)
}
